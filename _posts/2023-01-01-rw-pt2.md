---
title: Refactoring GitOps repository to support both real-time and reconciliation window changes
layout: post
post-image: "https://raw.githubusercontent.com/MahrRah/mahra.dev/master/assets/images/blog-image_rwpt2.jpg"
description: Restructuring GitOps repository to be able to enable multiple reconciliation types. eg real-time and reconciliation window changes with the approach descript in
tags:
  - K8s
  - Flux
  - GitOps
---

<style>
td, th {
   border: none!important;
}
table th:first-of-type {
    width: 10%;
}
table th:nth-of-type(2) {
    width: 10%;
}
t
</style>

> **TL;DR: Restructuring GitOps repository to be able to enable multiple reconciliation types. eg real-time and reconciliation window changes with the approach descript in [part 1 of this blog](rw-pt1)** <br/>
  _If you haven't already read the first part, go back and do so, as we will use its approach on how to enable the reconciliation window in this blog._

For some scenarios allowing only updates to be applied during a reconciliation window is not enough.
There are cases when some application resources should be managed at real time, but others are still only allowed to change during a reconciliation window.
The example we use here is a `nginx` deployment to the cluster, which contains a `Deployment`, a `Service`, `Namespace`, and a `ConfigMap`. 
The `ConfigMap`., which defines the `nginx.conf` should me manageable at real time. However the `Deployment` and the `Service` should only be changed with in a reconciliation window.


Hence, the problem statement changes slightly from the last part:

_We want to enable two ways of applying changes to a cluster using Flux:_

- _**Real-time changes:** Representing the default behavior of Flux when it comes to reconciling changes._
- _**Reconciliation windows changes:** Predefined time windows in which a change can be applied to the resource by Flux._

We can still use the core approach shown in [part 1](rw-pt1) of this series to solve our new problem. However, we need to make some small adjustments to how we organize our GitOps repository, to enable real-time as well as reconciliation window changes.

Even though we are only demonstrating the restructuring of this GitOps repository on two reconciliation types. This approach can easily be extended for more types. Just note when adding multiple reconciliation window types, additional set of of CronJobs are needed to manage the new windows.

## Core Principles

Before we start restructuring the repository, it might be useful to understand why we have to do so in the first place.
As you saw in the previous blog the granularity of control, we have on when changes get applied to the cluster, stops at the set of resources that are controlled by one `Kustomization` resource.
This means, to be able to control the reconciliation cycle differently for a group of resources, these resources need to be managed by an independent `Kustomization` resource.

So bottom line the goal of the next few sections are:
"Restructure the GitOps repository such that its resources can be managed by one of the N-`Kustomization` resource we will create.
Where N defined the different ways of applying changes."

Given in this blog we are only interested in real-time and reconciliation window changes, N is equal to 2.

## Set up

### 1. Set up your applications or components

Let's start with the smallest unit of grouping we have in our GitOps repository: `apps`

Looking at the example in [this sample](https://github.com/MahrRah/flux-maintanance-windows-sample/tree/master/Sample2), under `apps` we have an `nginx` folder, which contains the `Deployment`, a `Service`, `Namespace`, and a `ConfigMap` manifest.

<pre><code>
apps
└── nginx
    ├── deployment.yaml
    ├── service.yaml
    └── configmap.yaml
</code></pre>

As mentioned, we want to now make sure we can change the `nginx` server configuration, defined in the `configmap.yaml` in real-time, but infrastructure changes such as deployment and the service should only change between Monday 8 am to Thursday 5 pm.

To enable this, the first step is to make sure we can split resources that can be changed real-time from resources that can only change state during a reconciliation window from [`kustomizes`](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/) point of view.

> Note: If you are not familiar with how `kustomize` is used to manage resources check out the official doc from Kubernetes on this [Overview of Kustomize](https://kubernetes.io/docs/tasks/manage-kubernetes-objects/kustomization/)

There are multiple ways to do this:

1. We keep the existing structure and just remove the reference of resources of one changed type and reference them from another `kustomization.yaml`.
   As complicated as this sentence sounds, the more complicated will the GitOps repository eventually become, due to the obscurity of what resource is referenced from where. So this approach is fine for a small sample, but when scaled it can become pretty unmanageable. 
2. Splitting all the resources for each application we have defined under `apps/` (see [default GitOps folder structure for mono repos](https://fluxcd.io/flux/guides/repository-structure/#repository-structure)) into two versions. These versions' sole purpose is to package the resources to be either managed by the real-time or the reconciliation window `Kustomization` resource.
   The advantage of this approach is that there is no need to go find in which `kustomizatin.yaml` resources are referenced, to understand if they are managed by the real-time or the reconciliation window `Kustomization` resource.

For maintainability reasons, we will use the second option. We can then split all manifest files into these two subfolders and add the respective suffixes to the subfolders:

- Real-time changes: `-rt`
- Reconciliation windows changes: `-rw`

<table>
<tr>
<th>Origin </th>
<th>Enabeling real time and reconciliation windows changes </th>
</tr>
<tr>
<td>
  
<pre class="text"><code >
apps
└── nginx
    ├── deployment.yaml
    ├── service.yaml
    └── configmap.yaml
</code></pre>
  
</td>
<td>

<pre class="text"><code >
apps
└── nginx
    ├── nginx-rt
    │   └── configmap.yaml
    └── nginx-rw
        ├── deployment.yaml
        └── service.yaml
</code></pre>

</td>
</tr>
</table>

Result of this you can see in the sample repository [here](https://github.com/MahrRah/flux-maintanance-windows-sample/tree/master/Sample2/apps/nginx)

### 2. Set up your clusters

The next step is to restructure the clusters directory. The goal is to make sure we can create two independents `Kustomization` resources. This means we need two entry points to point each of the `Kustomization` resources to.
For that we split the previous `apps` into two subfolders, `apps-rt`/`apps-rw`.
Where `./cluster/cluster-1/apps/apps-rt` will be the entry point for the real-time `Kustomization` resources and `./cluster/cluster-1/apps/apps-rw` for the reconciliation window controller.

The folder structure compared side-by-side from before:

<table>
<tr>
<th>Origin </th>
<th>Enabeling Realtimeand Reconciliation windows changes </th>
</tr>
<tr>
<td>

<pre><code>
clusters/edge-01
├── apps
│    └── nginx
└── infra
     └── reconciliation-windows
</code></pre>

</td>
<td>

<pre><code>
clusters/cluster-1
├── apps
│   ├── apps-rw
│   │   └── nginx
│   └── apps-rt
│       └── nginx
└── infra
      └── reconciliation-windows

</code></pre>

</td>
</tr>
</table>

Next, we need to add the `kustomization.yaml` and make sure they reference the right resources. 

Let's first have a look at the the `kustomization.yaml`  in `clusters/cluster-1/apps/app-rw` and `clusters/cluster-1/apps/app-rt` setup.
Both `app-rw` and `app-rt` will have a root `kustomization.yaml` which will point to all applications deployed onto the cluster. In our example, this is only `nginx`.

<table>
<tr>
<th>Folder structure </th>
<th><code>kustomization.yaml</code></th>
</tr>
<tr>
<td>

<pre><code>
clusters/cluster-1
├── apps
│   ├── apps-rw
│   │   ├── kustomization.yaml
│   │   └── nginx
│   └── apps-rt
│       ├── kustomization.yaml
│       └── nginx
└── infra
</code></pre>

</td>
<td>

<pre><code>
#clusters/cluster-1/apps/apps-rw/kustomization.yaml
resources:
  - ./nginx

</code></pre>
<pre><code>
#clusters/cluster-1/apps/apps-rt/kustomization.yaml
resources:
  - ./nginx
</code></pre>

</td>
</tr>
</table>


Going one level deeper, both the `nginx` under `clusters/cluster-1/apps/app-rw` and `clusters/cluster-1/apps/app-rt` have a similar setup. 
To not go over the same thing twice, we are going to onely have look at the `clusters/cluster-1/apps/app-rt`. To see the setup of the `app-rw` you can check the sample  [here]().

<table>
<tr>
<th>Folder structure </th>
<th><code>kustomization.yaml</code></th>
</tr>
<tr>
<td>

<pre><code>
clusters/cluster-1
├── apps
│   ├── apps-rw
│   └── apps-rt
│       ├── kustomization.yaml
│       └── nginx
│           └── kustomization.yaml
└── infra
</code></pre>

</td>
<td>

<pre><code>
#clusters/cluster-1/apps/apps-rt/nginx/kustomization.yaml
resources:
- ./../../../../../apps/nginx/nginx-rt
</code></pre>

</td>
</tr>
</table>

As shown above, the application resources referenced under `clusters/cluster-1/apps/apps-rt` are the resources we bundled up under `apps/nginx/nginx-rt` and should now only contain resources that can be changed in real-time.

And just like that you have separated all configurations to be managed by different `Kustomization` resources!

#### Real-time update of window times

We now only enable real-time and reconciliation window changes for the applications, which are defined under `apps`. By doing the same above steps with the `infra` folder, we could enable the reconciliation window times to be also changed in real-time .

### Set up `Kustomization` resources.

Our GitOps repository is ready now, but how do we set up the `Kustomization` resources?
Let's first create a flux `Source` resources.

```sh
flux create source git source \
    --url="https://github.com/<github-handle>/flux-maintanance-windows-sample" \ 
    --username=<username>\
    --password=<PAT> \
    --branch=master \
    --interval=1m \
    --git-implementation=libgit2 \
    --silent
```

Next, we now need two controllers for apps and two for infra.
Replace therefore the `-<suffix>` once with `-rt` and once with `-rw`

```sh
flux create kustomization infra \
    --path="./clusters/edge-01/infra" \
    --source=source\
    --prune=true \
    --interval=1m
```

```sh
flux create kustomization apps-rt \
    --depends-on=infra \
    --path="./clusters/edge-01/apps/apps-<suffix>" \
    --source=source\
    --prune=true \
    --interval=1m
```

```sh
flux create kustomization apps-rw \
    --depends-on= apps-rt \
    --path="./clusters/edge-01/apps/apps-<suffix>" \
    --source=source\
    --prune=true \
    --interval=1m
```

Not this should give you something like this.

```sh
user@cluster:~$ flux get kustomization
NAME    REVISION        SUSPENDED READY MESSAGE
infra   master/7cf3aaf  False     True  Applied revision: master/7cf3aaf
apps-rt master/7cf3aaf  False     True  Applied revision: master/7cf3aaf
apps-rw master/7cf3aaf  False     True  Applied revision: master/7cf3aaf
```

# Example

Now that the cluster is set up, we can upgrade the `nginx` version and change the configuration `nginx.conf` to include the `nginx_status` endpoint and see how one is visible right away, while the other needs a reconciliation window to open. 

#### 1. Initial state
Before we do any changes, we can check out the current state of the nginx deployment. 
If we navigate to the `http://<ip>:8080/` we should see somehing like this
![Index_of__.jpg](quiver-image-url/69B6992E30F69FAAE5E73351CB5D9690.jpg =816x217)

We can download the `nginx.conf` file and see what  configuration is currently mounted into the `nginx` pod from the `ConfigMap`.

#### 2. Change state

The next step is to change the state of our application.
To change the state of the application we can change the image version number from `1.14.2` to the (currently) newest image `1.23.X` in the `deployment.yaml`.  And in the same commit,  we can add the configuration shown below to the `nginx.conf` in the `configmaps.yaml` file to include the new status endpoint. 

```conf
location /nginx_status {
                stub_status;
                allow all;
            }
```

The endpoint will only be accessible after a pod restart, but we will still be able to see the config changes in the `nginx.conf` file.

#### 3. See real-time changes

Now if we go back to the browser and check the file `nginx.conf` again, we should see the new section.

> Note: It might take up to 2 minutes in the worst case for the `Source` and then `Kustomize` Controler to reconcile

#### 4. Wait for reconciliation window to open

If we now wait till the next reconciliation window opens, the pod should be restarted and we should be able to see the version either by checking the resource.

```bash
kubectl describe pod  <nginx-podname> -n nginx
```

Or go to a non-existing route in the browser and you should see it on the 404 page
eg. navigate to `http://<ip>:8080/settings/`

# Conclusions

After this second part, you should be good to go on using these reconciliation windows and also have the knowledge on how to customize your setup as much as you want :)
Hope it was helpful and that you can solve your problems when it comes to managing your resources with Flux.

---

_Image credit: K.Oh_
